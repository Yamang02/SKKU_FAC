
---

## 예상 면접 질문

1. 이 프로젝트를 기획하게 된 계기와 목적은 무엇인가요?
2. 실제 사용자(회원/비회원)의 주요 사용 흐름은 어떻게 되나요?
3. 프로젝트 진행 과정에서 기획이나 요구사항이 변경된 부분이 있다면?
4. 바닐라 JS와 EJS를 사용한 이유는 무엇인가요? SPA 프레임워크는 고려하지 않았나요?
5. Express와 Sequelize를 선택한 이유는 무엇인가요?
6. ORM 사용 중 Query 최적화나 N+1 문제를 마주친 적이 있나요?
7. Cloudinary를 선택한 이유는 무엇인가요? S3 등의 대안은 고려했나요?
8. Railway 배포에서 겪은 한계나 장점은 어떤 것이었나요?
9. 세션 기반 인증을 선택한 이유는? JWT는 고려하지 않았나요?
10. 도메인 폴더 구조를 나눈 기준은 무엇인가요?
11. DDD 스타일 구조에서 실제 유지보수에 도움이 된 예시가 있나요?
12. infrastructure와 domain을 명확히 나눈 이유와 장점은 무엇인가요?
13. 도메인 구조에서 Controller, Service, Model을 어떻게 구분하고 연결했나요?
14. `ArtworkExhibitionRelationship` 같은 관계 모델은 어떤 기준으로 설계했나요?


## 1. 프로젝트 개요

- 이 프로젝트를 기획하게 된 계기와 목적은 무엇인가요?

	Summary : **포트폴리오 목적, Cursor AI 활용, 미술 동아리 경험 활용**

	A. 웹 개발자로서의 포트폴리오 생성이 목표였습니다. 특히, Cursor AI 툴을 통한 '바이브코딩'이 어느 수준까지 가능할지 궁금했고 기술스펙의 확장의 필요성도 느끼고 있었습니다. 그래서 기본적인 틀은 Cursor IDE 의 사용과 지금까지 다뤄보지 않았던 Express 프레임워크의 사용으로 가닥잡았습니다.
	콘텐츠는 개인적으로 필요성을 느끼고 있었던 예술작품 아카이브를 기획하였고 대학생 때 활동했던 미술 동아리에서의 경험과 인맥을 살려 기초적인 흐름을 잡아 실사용까지 확장하는 것을 목적으로 삼았습니다.

- 실제 사용자(회원/비회원)의 주요 사용 흐름은 어떻게 되나요?

	Summary : **비회원도 조회 가능, 회원은 등록 가능, 전시회 연계 가능**

	A. 전시 아카이브라는 사이트 목적에 맞게, 전시회와 작품의 조회는 로그인 여부와 상관없이 가능토록 구현했습니다. 사용자는 다양한 루트를 통해(홈페이지 주요 작품, 전시회별 작품 검색 등) 작품의 상세정보에 접근할 수 있게 구현하였습니다. 작품 등록은 회원만 가능하도록 구현하였습니다. 작품을 미리 사이트에 등록해 둔 뒤 추후에 전시회에 출품하거나, 전시회를 지정해 자신의 작품을 등록한 후 일부 정보들은 수정할 수 있도록 하였습니다.

- 프로젝트 진행 과정에서 기획이나 요구사항이 변경된 부분이 있다면?

	Summary : **MVP 집중으로 기능 축소 (댓글, 공지사항 등 보류)**

	A. 초기 구상했던 기능은 현재보다 더 다양한 상태였습니다. 댓글 및 조회수, 공지사항 기능 등을 UI로도 만들어놨지만 MVP를 배포하는 것에 집중하고자 하여 해당 기능들은 제외한 상태로 작품과 회원 도메인으로 축소하여 개발을 진행하였습니다.

---

## 2. 기술 스택

### 2.1 프론트엔드
- 바닐라 JS와 EJS를 사용한 이유는 무엇인가요? SPA 프레임워크는 고려하지 않았나요?
- 자체 CSS를 사용했을 때 유지보수나 구조화 측면에서의 장단점은?

	Summary : **이해 용이성과 구조 분리 목적, CSS는 파일별 관리**

	A. 학원에서 React를 공부해본 경험이 있으나, 경력상 프론트엔드의 프레임워크, 라이브러리들을 직접 다뤄볼 기회는 적었습니다. 아무리 AI로 바이브코딩을 한다 하더라도 코드들을 훑었을 때 빠르게 이해가 가야한다고 생각했기 때문에 JS를 선택했습니다. 자체 CSS를 사용하는 것의 장점은 파일별로 역할을 비교적 명확하게 분리할 수 있는 것이 아니었나 싶습니다. ejs 파일에는 html 구조와 (SSR) 어떤 데이터가 포함되어야 하는지가 깔끔하게 보였고, 별도의 css파일에서 해당 뷰파일의 애니메이션, 스타일 등을 확인할 수 있었습니다. 단점으로는, 공통컴포넌트의 관리 및 클래스 관리가 까다로웠습니다. 단순한 레이아웃과 관련된 내용을 지정할 때에는 리액트처럼 태그 안에 스타일 요소들을 넣는 게 훨씬 더 간편할 것 같았습니다.

### 2.2 백엔드
- Express와 Sequelize를 선택한 이유는 무엇인가요?

	Summary : **Express는 구인공고 기반, Sequelize는 보편성**

	A. Express의 선택 이유는 단순했습니다. 구인공고들을 살펴봤을 때 눈에 띄는 빈도가 높아 선택했습니다. Sequelize 역시, ORM을 사용하겠다는 목적 아래 보편적인 JS ORM 라이브러리로 생각해 선택했습니다. ESM으로 개발하는데 Module로 선언했을 때 절대경로를 제대로 인식하지 못하는 문제라든지, 특정 디렉토리의 파일을 접근하지 못하는 문제 등은 Spring Boot를 사용할 때에는 경험해보지 못한 문제였습니다. 또한 어노테이션을 통한 라우팅이 아니라 별도의 라우터를 설정해야 하는 것도 Spring Boot와는 달라 새로운 경험이었습니다.


- ORM 사용 중 Query 최적화나 N+1 문제를 마주친 적이 있나요?

	Summary : **연관 작품 로직, 프로필 별 추가정보**

	A. 한 작품과 관련된 여러 작품들의 추가적인 정보를 가져오는 경우가 있었습니다. 작품 상세페이지 접근 시 동일 작가의 다른 작품, 혹은 해당 작품이 출품된 전시회의 다른 작품을 연계해서 보여줘야 했는데, 다음과 같이 구현하였습니다.
	1. 보여줄 작품 수 제한 : 최대 8개
	2. 우선순위 설정 : 동일 작가의 다른 작품 > 동일 전시회의 다른 작품
	3. 위 조건에 맞춰 Limit을 주며 DB 조회 후 반환
	이에 따라 동일 작가의 작품이 8개를 넘어갈 경우 동일 전시회의 다른 작품은 반환하지 않으며, 이러한 흐름은 Lazy Loading을 의도적으로 활용한 사례로 볼 수 있습니다. 즉, 관련된 모든 데이터를 한 번에 가져오는 것이 아니라, 필요한 조건에 따라 단계적으로 데이터를 조회하며 필요 시에만 다음 쿼리를 수행하였습니다. 또한, 사용자 프로필(UserProfile)이 성대생인지 외부인인지에 따라 추가 정보를 각각 다른 테이블에서 가져와야 하는 경우가 있었는데, 이는 Sequelize ORM의 `include` 옵션을 사용하여 Eager Loading 방식으로 해결하였습니다.


### 2.3 인프라
- Cloudinary를 선택한 이유는 무엇인가요? S3 등의 대안은 고려했나요?

	Summary : **비용 없는 테스트 목적, 향후 확장 고려**

	A. 가벼운 포트폴리오용 프로젝트기 때문에, 연습하는 동안 비용이 발생하지 않는 서비스를 찾아 선정하였습니다. 현재 테스트만 운영하고 있는 상황인데, 서비스가 발전해서 트래픽이 늘어나고 더큰 저장용량이 필요하다고 하면 다른 서비스들을 면밀히 살펴볼 듯 합니다.


- Railway 배포에서 겪은 한계나 장점은 어떤 것이었나요?

	Summary : **자동 HTTPS, DB 연결 편리함, 비용**

	A. Railway 배포는 생각보다 간단했습니다. 특히, 이전 회사에서 SSL 인증서 문제로 다른 팀원이 개발방향을 바꾸는 경우도 목격해 걱정했는데 Railway에서는 배포를 통해 자동으로 https public url을 주는 점이 좋았습니다. 더불어, 별도의 DB서버를 고민할 필요 없이 Railway 서비스에서 DB인스턴스를 생성해 내부 어플리케이션과 연결시킬 수 있다는 점이 비용적인 면에서 강점이 있었습니다.


### 2.4 보안
- 세션 기반 인증을 선택한 이유는? JWT는 고려하지 않았나요?

	Summary : **초기 SSR 설계, CSR로 일부 변경, 세션 통일이 유지보수상 효율적**

	 초기 기획 단계에서는 전체 시스템을 SSR 기반으로 설계하고 보안도 이에 맞춰 세션 기반 인증으로 진행했으나, 추후 사용자 경험 향상을 위해 메인 페이지를 CSR로 전환하였습니다. 작품 등록과 수정은 사용자와의 상호작용이 많은 메인 페이지에서 이루어지며, 해당 기능들은 인증이 필요한 작업입니다.
	 그러나 프로젝트의 구조상 관리자 페이지는 여전히 SSR로 구성되어 있고, 세션 기반 인증을 적용함으로써 하나의 인증 체계로 전체 시스템을 통일하는 것이 유지보수성과 보안 측면에서 더 효율적이라고 판단했습니다.
	 JWT를 도입할 경우, 세션과 토큰이 혼재되면서 인증 로직이 이중으로 분기되고, 로그아웃 및 만료 처리 로직도 복잡해질 수 있어 배제하였습니다.


---

## 3. 프로젝트 구조

- 도메인 폴더 구조를 나눈 기준은 무엇인가요?

	Summary : **DB 스키마 우선, 역할과 기능에 따라 세분화**

	A. 도메인 폴더를 나눈 기준은 DB스키마를 우선적으로 고려하였습니다. 스키마 내에서 하나의 테이블 내에 묶인 정보들이 어플리케이션에서도 밀접한 관련을 가질 가능성이 높기에 가장 큰 도메인 분류는 이를 먼저 고려했고, 기능적으로 생각했을 때 여러 도메인에 걸쳐 공통적으로 쓰이는 기능들이나, 사용자의 역할에 따라 기능과 로직들을 한번에 보아야 할 필요성이 있는 경우 별도의 도메인으로 배치하였습니다. 개발 중 필요에 따라서 추가한 도메인도 있습니다.

- DDD 스타일 구조에서 실제 유지보수에 도움이 된 예시가 있나요?

	Summary : **불필요 기능 제거, 인증 모듈 분리로 도메인 경량화**

	A. 도메인들을 분리해 두었기에 공지사항과 댓글 기능을 추후에 도입한다는 기획변경 시 관련 코드를 걷어내는 과정이 매우 간편했습니다. 역으로, 토큰인증을 별도의 도메인으로 분리한 후 복잡했던 User 도메인의 코드들이 간결해질 수 있었습니다.

- infrastructure와 domain을 명확히 나눈 이유와 장점은 무엇인가요?

	Summary :  **외부 시스템 독립성 확보, 코드 영향 최소화**

	A. 처음 프로젝트를 구상했을 때부터, 어플리케이션 서버, DB 서버, 파일 서버의 분리를 고려하고 있었습니다. DB와 파일서버는 어플리케이션 내 도메인의 로직에 종속되지 않고 각 시스템과의 연결 및 통신에 집중하고 싶었습니다. 이의 장점은 현재 mysql + sequlize ORM 과 cloudinary의 구조에서 파일서버 혹은 DB, ORM 라이브러리가 변경시 domain에 속한 코드에 대한 영향을 최소화했다는 것입니다.


---

## 4. 주요 모듈

- 도메인 구조에서 Controller, Service, Model을 어떻게 구분하고 연결했나요?

	Summary : **Controller는 파라미터 및 반환 처리, Service는 로직/호출, Model은 데이터 구조 전담**

	A. Controller는 View, 혹은 API 호출(ApiController로 분리)에 대해 파라미터 값을 관리하고 서비스를 호출한 뒤 반환받은 내용 처리를 담당하는 코드들로 설정했습니다.  Service는 타 서비스의 호출, DB의 레포지토리 클래스의 호출과 자체적인 로직들로 구성했습니다. Model에는 별도의 Validation이나 로직 포함은 없이 초기값을 포함한 데이터 구조만 담았습니다. 프로젝트 규모가 작아 Model의 Depth가 깊게 들어가지 않았습니다만, Dto들을 통해 다른 서비스나 도메인, 레이어로 전송 간 명확한 데이터 구조를 유지하는 것이 목적이었습니다.

- `ArtworkExhibitionRelationship` 같은 관계 모델은 어떤 기준으로 설계했나요?

	Summary : **1:N 관계 고려해 관계 테이블 도입**

	A. 초기 기획에서는 하나의 작품을 전시회 한 곳에만 출품할 수 있게 하려다가, 특별전시회 등에는 기출품된 작품을 재출품할 수 있다는 것을 반영했습니다. 기존 기획대로면 작품 테이블에 전시회ID 컬럼을 추가해서 관리해도 큰 문제가 없지만, 변경된 내용처럼 1:0~N 관계가 되면  전시회별 작품을 확인하는 데에 문제가 발생하여 관계 테이블을 설정하였습니다. 해당 테이블의 존재로 작품의 전시회 출품과 출품취소, 전시회별 작품목록과 관련된 기능들을 손쉽게 구현할 수 있었습니다.


